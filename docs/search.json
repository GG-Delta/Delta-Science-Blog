[
  {
    "objectID": "posts/post-two/index.html",
    "href": "posts/post-two/index.html",
    "title": "Using Jupyter Notebook in virtual environments in a free source-code editor (VSCodium/VS Code)",
    "section": "",
    "text": "Working on data-science projects often requires to present, showcase and explain interactive source-code and data visualization within a single document. Jupyter Notebook is a tool providing exactly that. In the following lines I will briefly lead you through an exemplary setup that combines Jupyter Notebook running in a specified virtual environment with the fully open-source editor VSCodium (free alternative to VS Code). Following these lines should lead you to a productive setup where you can document your data-science projects in the form of a Jupyter Notebook, while editing its content via the extremely capable VSCodium editor.\nBefore you proceed, please ensure that both of the following conditions are met:\n\nYour computer has a version of Python 3 installed, and\nYour computer is prepared to initialize and run a virtual environment\n\nIf you need assistance or a refresher on these topics you can take a look here: Blog-Post-01.\nI wrote this summary using macOS (version: 12.6), but you should be able to follow equivalent steps on Linux or Windows (you might need to make some modifications)."
  },
  {
    "objectID": "posts/post-two/index.html#install-and-setup-vscodium",
    "href": "posts/post-two/index.html#install-and-setup-vscodium",
    "title": "Using Jupyter Notebook in virtual environments in a free source-code editor (VSCodium/VS Code)",
    "section": "1. Install and setup VSCodium",
    "text": "1. Install and setup VSCodium\nAs a first step you should download and install (in case you don‚Äôt have it) the fully open-source editor VSCodium which is known as the free alternative for the popular VS Code editor of Microsoft. Please follow one of the following options:\n\nInstall via brewInstall via .dmg\n\n\nIn case you have followed the steps in my earlier post (Blog-Post-01), you will have homebrew already installed on your computer. If not, please consider to get homebrew: it is a very useful and straightforward package manager (for macOS/Linux).\nNow, assuming your computer has homebrew installed, please open a terminal window (you can do this by opening macOS spotlight - or via your keyboard: just hit both keys command + space at once - then type ‚Äúterminal‚Äù and open this application).\nIn your open terminal window enter and execute the following command to install the VSCodium editor:\nbrew install --cask vscodium\n\n\nA list of the most recent VSCodium releases in various formats can be found here. Open this link and scroll down to the .dmg file section and download the appropriate file matching your computer‚Äôs architecture (note the respective suffix of the listed file names: .arm64. should used for newer Macs built on Apple Silicon, while .x64. for all Intel Macs).\nAfter downloading the .dmg file, double-click the file to open it, and you‚Äôll see a Finder window. Simply drag the VSCodium icon into the Applications folder and you are done with the installation.\n\n\n\nTo prepare the editor for Jupyter Notebook we just need to install and enable the following extension: just navigate to the left vertical menu column of VSCodium and open the section called ‚ÄúExtensions‚Äù (keyboard shortcut: shift + command + X). You can see the arrow in the color highlighted screenshot below.\n\n\n\nVSCodium: Select and open the extension section\n\n\nWithin the extensions window of VSCodium you will see a search mask (top left corner): enter there the word ‚ÄúJupyter‚Äù and search in the resulting list for the extension option called ‚ÄúJupyter Extension for Visual Studio Code‚Äù that is published by ms-toolsai. Click on the installation button displayed next to it. After the installation you should see the updated status of this extension reflected by both buttons ‚Äúdisable‚Äù and ‚Äúuninstall‚Äù - see the screenshot below:\n\n\n\nVSCodium: Extensions window\n\n\n\n\n\n\n\n\nSmart move: Include Python extension\n\n\n\n\n\nSince you are already in the right place it will not hurt (quite the contrary) to include another extension, namely ‚ÄúPython‚Äù published by ms-python. This extension (its complete title is ‚ÄúPython extension for Visual Studio Code‚Äù) provides extensive language support for Python with code editing features such as code completion, parameter info, quick info etc."
  },
  {
    "objectID": "posts/post-two/index.html#activate-an-existing-virtual-environment-and-install-two-fundamental-python-packages",
    "href": "posts/post-two/index.html#activate-an-existing-virtual-environment-and-install-two-fundamental-python-packages",
    "title": "Using Jupyter Notebook in virtual environments in a free source-code editor (VSCodium/VS Code)",
    "section": "2. Activate an existing virtual environment and install two fundamental Python packages",
    "text": "2. Activate an existing virtual environment and install two fundamental Python packages\nTo manage virtual environments I am using the extremely useful tool virtualenvwrapper. In an earlier post I explained the use of virtual environments together with a detailed instruction of their setup and management (please see here).\nUsing the workon command from virtualenvwrapper without any additional expressions enlists all virtual environments that are currently available on your computer. In our exemplary case provides the terminal window provides the following output (listing three already created virtual environments):\nmyusername@mbp ~ % workon\nmyenv_dwork01\nmyenv_dwork02\nmyenv_test1\nTo activate one specific virtual environment we just need to use the workon command from virtualenvwrapper together with the name of the virtual environment (for our example let‚Äôs choose myenv_dwork2):\nmyusername@mbp ~ % workon myenv_dwork02\nAfter having activated the selected virtual environment successfully you will note that the prompt of your terminal window has changed to this format: The activated virtual environment is explicitly stated within the round brackets:\n(myenv_dwork02) myusername@mbp ~ %\nNow we can proceed with installing the two required packages in this virtual environment using the pip command. Please execute the following command in your terminal window (the feedback from the terminal will tell you when the installation was concluded):\npip install ipykernel jupyter"
  },
  {
    "objectID": "posts/post-two/index.html#install-any-additional-python-packages-within-the-same-activated-virtual-environment",
    "href": "posts/post-two/index.html#install-any-additional-python-packages-within-the-same-activated-virtual-environment",
    "title": "Using Jupyter Notebook in virtual environments in a free source-code editor (VSCodium/VS Code)",
    "section": "3. Install any additional Python packages (within the same activated virtual environment)",
    "text": "3. Install any additional Python packages (within the same activated virtual environment)\nKeeping the same virtual environment activated (in our example case: myenv_dwork02) we can proceed with installing those packages that we intend to use later for our data project (within the Jupyter Notebook document).\nLet‚Äôs assume we know to use two very popular Python packages for data analysis (pandas) and data visualization (seaborn). We can install both packages by calling the following command (please add/modify the package names according to your needs) in your terminal window:\npip install -U pandas seaborn\nOne additional detail: The flag -U/--upgrade with the pip install command used above means to upgrade the specified packages to their latest version."
  },
  {
    "objectID": "posts/post-two/index.html#create-a-new-ipykernel-and-give-it-a-name",
    "href": "posts/post-two/index.html#create-a-new-ipykernel-and-give-it-a-name",
    "title": "Using Jupyter Notebook in virtual environments in a free source-code editor (VSCodium/VS Code)",
    "section": "4. Create a new ipykernel and give it a name",
    "text": "4. Create a new ipykernel and give it a name\nTo create and name the new ipykernel run the Python command shown below in your terminal window. You should give the new ipykernel a name: in our example I will call it myenv_dwork02_kernel (to underline the connection of the kernel with the virtual environment). Feel free to choose a name that suits your preferences:\npython -m ipykernel install --name=myenv_dwork02_kernel"
  },
  {
    "objectID": "posts/post-two/index.html#create-a-new-jupyter-notebook-document-and-open-it-with-your-vscodium-editor",
    "href": "posts/post-two/index.html#create-a-new-jupyter-notebook-document-and-open-it-with-your-vscodium-editor",
    "title": "Using Jupyter Notebook in virtual environments in a free source-code editor (VSCodium/VS Code)",
    "section": "5. Create a new Jupyter Notebook document and open it with your VSCodium editor",
    "text": "5. Create a new Jupyter Notebook document and open it with your VSCodium editor\nWe managed to reach the very last step of our setup. To that end we just need to create a fresh (empty) Jupyter Notebook document (having the file extension .ipynb) and open this file in our VSCodium editor.\nBefore creating the new .ipynb file we should decide where we want to create this file: it seems to be conveniant practice to establish a dedicated folder for a given data project. Therefore, I will create such a folder (to be named dwork02) within my home directory by executing the following lines in the terminal window:\nmkdir  ~/dwork02 \nBy calling the touch command we will now create the .ipynb file (to be named new_noteb) in the project folder we have just created:\ntouch ~/dwork02/new_noteb.ipynb\n\n\n\n\n\n\nSome nice shortcuts\n\n\n\n\n\nYou can create the folder and the .ipynb file also in just one single line as follows:\nmkdir  ~/dwork02 && touch ~/dwork02/new_noteb.ipynb\nIn case you want to establish a new directory together with its full directory structure, you can call mkdir together with the flag -p/--parents (this option will make sure that directories are created where needed - in case a given directory already exists no error will be triggered):\nmkdir -p  ~/Coding/dwork02 && touch ~/Coding/dwork02/new_noteb.ipynb\n\n\n\nAfter having created the fresh Jupyter Notebook file we should open it now from within the VSCodium editor. To do so, start the VSCodium application, select from the main top-bar menu the section File and choose Open (see the screenshot below).\n\n\n\nVSCodium: Open the created .ipynb file\n\n\nBrowse to the location, where you just have created the new .ipynb file (in our example this is the dwork_02 directory) and open this file. Now, when the notebook opens up in your editor, click on the kernel picker located in the top right corner (see the arrow and marked highlight below):\n\n\n\nVSCodium: Location of the kernel picker (button)\n\n\nAfter clicking the kernel picker you will see a list of possible kernels to choose from (see the screenshot with the marked highlights below). Following our example case we will select the kernel named myenv_dwork02_kernel (or whatever you have named your kernel before).\n\n\n\nVSCodium: List of available kernels\n\n\nIf you don‚Äôt see your previously created kernel in the kernel list, close VSCodium completely and re-open it. It should now appear in the refreshed list as shown above.\nWhen you have your brand-new Jupyter Notebook document open in VSCodium and your selected kernel is running (as indicated by the kernel picker in the top right corner: please see the highlighted screenshot below) you have made it! Congratulations!\n\n\n\nVSCodium: Selected kernel running in new Jupyter notebook file\n\n\n\n\n\n\n\n\nHow to add a new Python package to the current Jupyter kernel?\n\n\n\n\n\nImagine that you have not included all python packages that you need to use in your Jupyter notebook at the time when you initialized its setup (see step 3). Don‚Äôt worry! You can still do it within your running Jupyter notebook.\nFor a concrete example let‚Äôs say we want to include the great machine learning package yellowbrick to our current kernel: just add a new code cell in your Jupyter notebook, then paste and run the following code in this cell of the notebook:\nimport sys\n!{sys.executable} -m pip install yellowbrick\n\n\n\nHappy coding & Cheers! üòÉ"
  },
  {
    "objectID": "posts/post-one/index.html",
    "href": "posts/post-one/index.html",
    "title": "Save time & nerves: start controlling different Python versions (pyenv) and managing virtual environments (virtualenvwrapper)",
    "section": "",
    "text": "Most people‚Äôs computers have multiple Python versions installed (macOS comes with Python pre-installed, often termed system Python). Keeping these versions (the pre-installed system Python version and other user-installed Python versions) separate and controlling them independently (e.g.¬†installing or updating a given Python package for a specific Python version only) requires an upfront solution.\nWorking with virtual environments, i.e.¬†having a separate workspace for each individual project, necessitates actively defining the Python version that will be used to create a specific virtual environment. Controlling Python versions is thus linked to the task of managing virtual environments. All packages installed in a specific virtual environment will not conflict with other virtual environments (all packages being contained in that particular workspace).\nFollowing the steps outlined here below, your computer should be in a state where different Python versions coexist peacefully and where you can safely install, upgrade, or remove libraries without affecting other projects. In fact, a working setup that is simple to maintain."
  },
  {
    "objectID": "posts/post-one/index.html#install-the-homebrew-package-manager",
    "href": "posts/post-one/index.html#install-the-homebrew-package-manager",
    "title": "Save time & nerves: start controlling different Python versions (pyenv) and managing virtual environments (virtualenvwrapper)",
    "section": "1. Install the homebrew package manager",
    "text": "1. Install the homebrew package manager\nAs a first step you should install homebrew which is a very useful and straightforward package manager (for macOS/Linux). In order to enter the code below open a terminal window (you can do this by opening macOS spotlight - or via your keyboard: just hit both keys command + space at once - then type ‚Äúterminal‚Äù and open this application).\nNow that you have your terminal window open, you can enter the following commands shown below (select the commands matching your case):\n\nInstall homebrewCheck homebrew (installed/version)Update homebrew\n\n\nTo install homebrew on your computer: paste this command in your terminal window and hit enter. After hitting enter the script will explain what it will do and then pauses before it does it:\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\n\n\nTo verify and check whether you have homebrew already installed, you can enter the command shown below. In the case you have homebrew installed, the output will tell you which version it is. If you don‚Äôt have it installed yet, the output will tell you something like command not found.\nbrew --version\nExample output in case your computer has homebrew already installed (your version might differ):\nHomebrew 3.6.6 \nHomebrew/homebrew-core (git revision 7ec3c2d24e8; last commit 2022-10-24) \nHomebrew/homebrew-cask (git revision c3048a8013; last commit 2022-10-24)\n\n\nAfter having verified that your computer has homebrew installed, update it to make sure you have the latest version. Just enter the following command in your terminal window and hit enter [*].\nbrew update"
  },
  {
    "objectID": "posts/post-one/index.html#install-pyenv-via-homebrew",
    "href": "posts/post-one/index.html#install-pyenv-via-homebrew",
    "title": "Save time & nerves: start controlling different Python versions (pyenv) and managing virtual environments (virtualenvwrapper)",
    "section": "2. Install pyenv (via homebrew)",
    "text": "2. Install pyenv (via homebrew)\n2a: Run the following installation command in the terminal [*].\nbrew install pyenv\n2b: Now you need to configure your terminal (or shell) in a way so that the pyenv commands will be loaded. You do this by editing the configuration file of your terminal represented by .zshrc, .bashrc or other file types (sometimes subsumed under the term ‚Äúshell‚Äôs rc file‚Äù, the affix means ‚Äúrun commands‚Äù). Given that macOS default is based on the zsh Unix shell - also known as Z shell - we will focus to edit only this configuration file (for other options please see this manual: [*]). The configuration file for zsh is called .zshrc and is located in your home folder (~/.zshrc).\nBefore trying to edit a file we should make sure that the hidden .zshrc file is actually there:\n\nCheck .zshrc via FinderCheck .zshrc via TerminalCreate .zshrc file (if its not there)\n\n\nTo view the hidden .zshrc file in your home directory you can do the following within macOS Finder: Open Finder and navigate to your home directory (e.g, something like /Users/MyUserName): hit the following keys at once: Command + Shift +.\nBy using this command you told Finder to display usually hidden files (i.e.¬†files starting with a dot). If you see the .zshrc file within Finder you can open it by selecting any text editing application (e.g.¬†TextEdit). In case there is no .zshrc file in your home directory, please create one: just see the instructions in this section (tab).\n\n\nOpen a terminal window (the hidden file should be located in your home folder: something like /Users/MyUserName/) and enter the following command:\nopen ~/.zshrc\nIn case this file doesn‚Äôt exist you will receive a respective feedback (‚Äúfile doesn‚Äôt exist‚Äù). In case there is no such .zshrc file in your home directory, please create one: just see the instructions in this section (tab).\n\n\nWithin your terminal window enter the following command:\ntouch ~/.zshrc\nThe operation starting with touch will create the hidden .zshrc file in your home directory. You can verify the creation of this file by following one of the options shown in this section (see other tabs).\n\n\n\nSince we made sure that the configuration file for our shell is indeed available (i.e., the .zshrc file) we can now add the following three expressions to this configuration file. To add these modifications to your shell‚Äôs configuration enter the following commands in your terminal:\necho 'export PYENV_ROOT=\"$HOME/.pyenv\"' >> ~/.zshrc\necho 'command -v pyenv >/dev/null || export PATH=\"$PYENV_ROOT/bin:$PATH\"' >> ~/.zshrc\necho 'eval \"$(pyenv init -)\"' >> ~/.zshrc   \nAfter having executed these commands your .zshrc file will have three new lines included.\n\n\n\n\n\n\nNote\n\n\n\n\n\nYou can verify the successful installation and setup of pyenv by entering the following command in your terminal window:\npyenv\nIf all went fine, you should receive the output of the actual version of pyenv installed. In my case the output is as follows:\npyenv 2.3.5\nIn addition, you should see a list of command options (e.g.¬†‚Äú--version‚Äù, ‚Äúcommands‚Äù, ‚Äúexec‚Äù and several more).\nWith pyenv installed successfully you can get a nice overview about all installed Python versions: just enter the following pyenv command:\npyenv versions\nSince we haven‚Äôt yet installed any additional Python version, pyenv will show you the system Python version (pre-installed on our macOS): you will see something like this (exemplary output):\n  * system (set by /Users/MyUserName/.pyenv/version)\nGiven that no other version of Python is installed pyenv is enlisting the Python system version. The star * symbol marks the Python version set to be global, that is the Python version that serves as the default version of Python which macOS uses when running Python applications.\nYou can use the following command to confirm the location of the Python system version:\npyenv which python3\nThis will show the following output:\n/usr/bin/python3\nThis shows the actual path to your system Python version.\nYou might be tempted to enter the traditional terminal command which python3 to locate the Python‚Äôs location. However, this command will reveal only the pyenv path modifications inserted in your shell‚Äôs configuration. In fact you will see something like this: /Users/MyUserName/.pyenv/shims/python3\n\n\n\n2c: We are now ready to pyenv in order to install a new Python version. In case you know the precise Python version you would like to install (for the sake of this example let‚Äôs say 3.10.5) simply execute the following pyenv command:\npyenv install 3.10.5\nTo verify which Python versions are installed and available on your computer just enter the following command we saw before:\npyenv versions\nThis time the output should look like along these lines:\n* system (set by /Users/ggs/.pyenv/version)\n  3.10.5\nThe output provides a list of all installed Python versions, while the star * symbol marks the Python version set to be global (default).\n\n\n\n\n\n\nNice to know: Which Python versions are available to install?\n\n\n\n\n\nIn case you would like to get a list of all Python versions that are available to be installed via pyenv you can use the following command (as a shortcut you can also type: pyenv install -l):\npyenv install --list\nThis command will give you a list of available Python versions (and additionally showing other libraries we can ignore for the moment) such as:\nAvailable versions:\n  2.1.3\n  2.2.3\n  2.3.7\n...\n  3.10.5\n  3.10.6\n  3.10.7\n...\n\n\n\n2d: For our current example we have seen two versions of Python installed on our computer. Using pyenv we can switch between these two Python versions, that is we can select one version and set it the global default: this global Python version will become the one macOS uses when running Python applications. Set a given Python version to global by executing the following command:\npyenv global 3.10.5\nWhen running the previously shown command pyenv versions again we will see that the Python version marked to be global has changed accordingly (exemplary output):\nsystem\n* 3.10.5 (set by /Users/MyUserName/.pyenv/version)\nAs intended the star * symbol marking the Python version set as global has changed. In case you have several more Python versions installed you can change to each one of them using the pyenv global command shown above.\nYou can change back to using your system Python version as the global one via the following command:\npyenv global system"
  },
  {
    "objectID": "posts/post-one/index.html#install-virtualenvwrapper-using-your-system-python-version-and-its-associated-pip-version",
    "href": "posts/post-one/index.html#install-virtualenvwrapper-using-your-system-python-version-and-its-associated-pip-version",
    "title": "Save time & nerves: start controlling different Python versions (pyenv) and managing virtual environments (virtualenvwrapper)",
    "section": "3. Install virtualenvwrapper using your system Python version (and its associated pip version)",
    "text": "3. Install virtualenvwrapper using your system Python version (and its associated pip version)\n3a: Before you continue please consider the following important requirement:\n\n\n\n\n\n\nImportant\n\n\n\n\n\nBefore continuing with installing the virtualenvwrapper library make sure that your system Python version is set to global (just run the command pyenv versions and verify that the star * symbol is shown next to the system Python version - as detailed in step 2 above). If that is not the case, you can simply set the system Python version to global by executing this command: pyenv global system.\n\n\n\nBeing sure that you are using the correct Python version i.e.¬†the system Python version, you can now run the following installation command. It will install the virtualenvwrapper library on your computer [*]\n(Note: The usage of the sudo command will require that you enter your admin password before the installation can be executed):\nsudo pip3 install virtualenvwrapper\n3b: Next, we need to configure your terminal to load the virtualenvwrapper commands, i.e.¬†we will modify the existing .zsrh file of your terminal in a way that the virtualenvwrapper commands can be used (we saw already a similar procedure for pyenv - see the details of step 2b). To add three modifications to your ~.zshrc file please execute the following three commands within your terminal window [*]:\necho 'export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3' >> ~/.zshrc\necho 'export VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/bin/virtualenv' >> ~/.zshrc\necho 'source /usr/local/bin/virtualenvwrapper.sh' >> ~/.zshrc\nYou can verify the three newly appended lines by opening the .zshrc configuration file: just enter this command in your terminal:\nopen ~/.zshrc \n3c: Finally, we ready to create our first virtual environment on the basis of our now established setup. However, before creating the virtual environment we need to make one last decision: Which Python version do we want to use in order to create this virtual environment?\nRemember: We can see which Python versions are actually installed on our computer by running the pyenv command pyenv versions. Executing this command within your terminal will in our example case lead to the following output:\n* system (set by /Users/MyUserName/.pyenv/version)\n  3.10.5\nAs detailed before (please check 2c) the output provides a list of installed Python versions, while one named ‚Äúsystem‚Äù is marked by the star * symbol indicating that this version is set to global so that it serves at the moment as the default version of Python. That is, the currently set default Python version is the system Python version. From here, we have two options to proceed:\n\nIn case we make the decision to use the system Python version to create a virtual environment we can now proceed with executing the respective virtualenvwrapper command (please see the tab below: Option I).\nIn case we want to use another Python version available on our computer (in our example: Python version 3.10.5), we first need to set this version to global. Only after having changed the default Python version (in our case to 3.10.5) we can then proceed with creating the virtual environment. Please see everything summarized in the tab below (Option II).\n\n\nOption I (using the system Python version)Option II (using a user-installed Python version)\n\n\nThe prerequisite for this option is that the system Python version is set to global (or in other words: when you have entered the terminal command pyenv versions and you see the star * symbol marking the Python version named ‚Äúsystem‚Äù). If this is not the case, just set the system Python version to global by using the pyenv command as shown before: pyenv global system.\nNow you can simply run the following virtualenvwrapper command with a name for the virtual environment of your choice (in the example below I will use the name myenv_test1) to create a new virtual environment:\nmkvirtualenv myenv_test1\nNote that executing this command above will create and at the same time activate the new virtual environment: you will notice that the prompt line in your terminal window has changed:\n\nmyusername@mbp ~ % (before)\n(myenv_test1) myusername@mbp ~ % (after)\n\nThe fact that (myenv_test1) appears before your prompt shows that this virtual environment is in fact activated. A virtual environment constitutes a separate and independent workspace: Any packages you install using pip will be installed within this workspace alone, so that they will not interfere with your other projects, other virtual environments, or your system installation. To work smoothly with virtual environment please see the most important commands (such as activating, deactivating, etc.) in the summary table below.\n\n\nFirst, we need to know which Python version is set to be the global default: as demonstrated before (see 2d) we get a list of all installed Python versions using this pyenv command: pyenv versions. The output is a list of Python versions, where one is marked by the star * symbol to indicate the version currently set to the global default. For our example case, let‚Äôs assume the output looks like the following:\n * system (set by /Users/MyUserName/.pyenv/version)\n  3.10.5\nWe decided that we want to use a new user-installed Python version to create a virtual environment. Therefore, based on the output shown above, we need to change the global Python version to 3.10.5. We will do this again by using the pyenv global command (see 2d):\npyenv global 3.10.5 \nWith this user-installed Python version (3.10.5) set to global, we can now create a new virtual environment based on this exact Python version. To that end, we will call the virtualenvwrapper command mkvirtualenv together with an additional flag argument -p and specifying the actual Python version to be used for creating the new virtual environment (I will name it this time myenv_test2):\nmkvirtualenv -p python3.10.5 myenv_test2\nExecuting this command above will create and at the same time activate the new virtual environment: this fact is also reflected by the change in the prompt line of your terminal window:\n\nmyusername@mbp ~ % (before)\n(myenv_test2) myusername@mbp ~ % (after)\n\nTo work smoothly with virtual environment please see the most important commands (such as activating, deactivating, etc.) in the summary table below.\n\n\n\nThe following table summarizes some important operations working with virtual environments provided by virtualenvwrapper (for a complete list please see the manual [*]).\n\nManaging virtual environments (virtualenvwrapper)\n\n\n\n\n\n\n\nDesired Outcome\nCommand\nComment\n\n\n\n\nCreate a virtual environment named ‚Äúmyenv_test1‚Äù\nmkvirtualenv myenv_test1\nThe creation of the virtual environment is based upon the Python system version\n\n\nCreate a virtual environment named ‚Äúmyenv_test2‚Äù which is based on a specified Python version\nmkvirtualenv -p python3.10.5 myenv_test2\nBefore specifying a user-installed Python version that version need to be set to global (see 2d)\n\n\nDeactivate the currently running virtual environment\ndeactivate\nAfter executing this command the prompt line of your window will have changed (see 3c)\n\n\nRe-enable an already created virtual environment named ‚Äúmyenv_test1‚Äù\nworkon myenv_test1\nAfter executing this command the prompt line of your window will have changed (see 3c)\n\n\nList all virtual environments currently available on your computer\nlsvirtualenv\nAs an alternative command you can also use workon without any additional arguments\n\n\nRemove the virtual environment named ‚Äúmyenv_test1‚Äù\nrmvirtualenv myenv_test1\nBefore removing a given virtual environment you first need to deactivate it\n\n\n\nAll these steps together should give you a clean and maintainable setup for all your Python coding work. I hope that my explanations helped you on the way. Happy coding & Cheers!"
  },
  {
    "objectID": "drafts/draft_01.html",
    "href": "drafts/draft_01.html",
    "title": "Delta-Science-Blog",
    "section": "",
    "text": "Summary (Context/Motivation/Problem/Solution) Most people‚Äôs computers have multiple Python versions installed (Macs come with Python pre-installed, often termed system Python). Keeping these versions (the pre-installed system Python version and other user-installed Python versions) separate and controlling them independently (e.g.¬†installing or updating a given Python package for a specific Phython version only) requires an upfront solution. Working with virtual environments, i.e.¬†having a separate workspace for each individual project, necessitates actively defining the Python version that will be used to create a specific virtual environment. Controlling Python versions is thus linked to the task of managing virtual environments. All packages installed in a specific virtual environment will not conflict with other virtual environments (all packages being contained in that particular workspace). Following the steps outlined below, your computer should be in a state where different Python versions coexist peacefully and where you can safely install, upgrade, or remove libraries without affecting other projects. In fact, a working setup that is simple to maintain.\nIntroduction\nA certainty, especially in the world of programming, is that there are numerous paths to the same destination.\nAs a result, there is a plethora of advice available on how to arrive at a working (and hopefully maintainable) setup of a local computer to do data science using Python.\nSpeaking from personal experience, I was always too busy doing the actual work to contemplate about the ‚Äúideal‚Äù setup, so I decided for the moment to ignore any best practices that might exist somewhere. Besides, given the vast amount of information available, determining the right blueprint to follow is not an easy task (just considering the combinatorial nightmare of different operating systems, python versions, installed or assumed pre-installed software, various IDEs etc etc). In short, there are many flying pieces and thus many degrees of freedom, which inevitably leads to complexity.\nHowever, sooner or later the day always comes when you can‚Äôt afford to ignore the Python setup issue any longer simply because something broke (e.g.¬†after installing a new Python package or upgrading an installed one). From that moment on you will be busy finding a way to continue your work. Sometimes a quick fix is possible (after consulting numerous entries at Stack Overflow or similar websites), but sometimes band-aid is not enough, so that you need a fundamental solution.\nIn order to spare you time, research effort and hopefully some nerves I will consicly summarize all steps that resulted into my tested setup. Each step builds on different sources of advice that I will cite along the way (i.e.¬†credits, attribution and thanks are given by explicit references).\nI wrote this summary using macOS (version: 12.6), but you should be able to follow equivalent steps on Linux or Windows (you might need to make some modifications).\nOne last word before going into the details: I mentioned the term ‚Äúfundamental solution‚Äù for a reason: in case you got totally lost with quick fixes that resulted in even more problems later on a fresh installation of the operating system is a radical approach. However, it provides a clean start from where you can begin building your new robust setup that is maintainable for all your future projects. I wrote the following lines with a fresh installation of the operating system in mind:\nBrief overview\nWe‚Äôll go through three main steps below. The following list is intended to provide you with a high-level overview. Each of the three main steps will be explained in the following paragraphs:\n1. Install the homebrew package manager (if you are not sure if you have it check it and eventually update it)\n2. Install pyenv (using homebrew)\n\n\nRunning the installation command in the terminal\n\n\n\nConfigure your terminal: setup your .zsrh file for pyenv\n\n\nUsing pyenv to install a new Python version (in addition to your system Python version)\n\n\nSwitching between the availability of different Python versions\n\n\n3. Install virtualenwrapper using your system Python version (and its associated pip version)\n\n\nRunning the installation command in the terminal\n\n\nConfigure your terminal to load the virtualenvwrapper commands\n\n\nSetup a new virtual envrionment on the basis of a specific Python version\n\n\n\n‚Äî title: ‚ÄúSave time and nerves by controlling different Python versions (pyenv) and managing virtual environments (virtualenvwrapper)‚Äù author: ‚ÄúGG Supp‚Äù date: ‚Äú2022-10-25‚Äù categories: [news, code, analysis] image: ‚Äúimage.jpg‚Äù format: html: code-copy: true draft: true ‚Äî"
  },
  {
    "objectID": "drafts/draft_01.html#install-the-homebrew-package-manager",
    "href": "drafts/draft_01.html#install-the-homebrew-package-manager",
    "title": "Delta-Science-Blog",
    "section": "1. Install the homebrew package manager",
    "text": "1. Install the homebrew package manager\nAs a first step you should install homebrew which is a very useful and straightforward package manager (for macOS/Linux). In order to enter the code below open a terminal window (you can do this by opening macOS spotlight - or via your keyboard: just hit both keys command plus space at once - type ‚Äúterminal‚Äù and open this application).\nNow that you have your terminal window open, you can enter the following commands shown below:"
  },
  {
    "objectID": "drafts/draft_01.html#install-homebrew",
    "href": "drafts/draft_01.html#install-homebrew",
    "title": "Delta-Science-Blog",
    "section": "Install homebrew",
    "text": "Install homebrew\nTo install homebrew on your computer: paste this command in your terminal window and hit enter. After hitting enter the script will explain what it will do and then pauses before it does it:\n{default} /bin/bash -c ‚Äú$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)‚Äù"
  },
  {
    "objectID": "drafts/draft_01.html#check-homebrew-installedversion",
    "href": "drafts/draft_01.html#check-homebrew-installedversion",
    "title": "Delta-Science-Blog",
    "section": "Check homebrew (installed/version)",
    "text": "Check homebrew (installed/version)\nTo verify and check whether you have homebrew already installed you can the following command. In case you have homebrew installed the output will tell you which version it is. If you don‚Äôt have it installed yet, the output will tell you something like command not found.\n{default} brew ‚Äìversion\nExample output in case your computer has homebrew installed (your version might differ):\n{default} Homebrew 3.6.6 Homebrew/homebrew-core (git revision 7ec3c2d24e8; last commit 2022-10-24) Homebrew/homebrew-cask (git revision c3048a8013; last commit 2022-10-24)"
  },
  {
    "objectID": "drafts/draft_01.html#update-homebrew",
    "href": "drafts/draft_01.html#update-homebrew",
    "title": "Delta-Science-Blog",
    "section": "Update homebrew",
    "text": "Update homebrew\nAfter having verified that your computer has homebrew installed, update it to make sure you have the latest version. Just enter the following command in your terminal window and hit enter [*].\n{default}"
  },
  {
    "objectID": "drafts/draft_01.html#install-pyenv-via-homebrew",
    "href": "drafts/draft_01.html#install-pyenv-via-homebrew",
    "title": "Delta-Science-Blog",
    "section": "2. Install pyenv (via homebrew)",
    "text": "2. Install pyenv (via homebrew)\n\nTotal OLD\n‚Äî title: ‚ÄúSave time and nerves by controlling different Python versions (pyenv) and managing virtual environments (virtualenvwrapper)‚Äù author: ‚ÄúGG Supp‚Äù date: ‚Äú2022-10-25‚Äù categories: [news, code, analysis] image: ‚Äúimage.jpg‚Äù draft: true ‚Äî"
  },
  {
    "objectID": "drafts/draft_01.html#install-the-homebrew-package-manager-1",
    "href": "drafts/draft_01.html#install-the-homebrew-package-manager-1",
    "title": "Delta-Science-Blog",
    "section": "1. Install the homebrew package manager",
    "text": "1. Install the homebrew package manager\nAs a first step you should install homebrew which is a very useful and straightforward package manager (for macOS/Linux). In order to enter the code below open a terminal window (you can do this by opening macOS spotlight - or via your keyboard: just hit both keys command plus space at once - type ‚Äúterminal‚Äù and open this application).\nNow that you have your terminal window open, you can enter the following commands shown below:"
  },
  {
    "objectID": "drafts/draft_01.html#install-homebrew-1",
    "href": "drafts/draft_01.html#install-homebrew-1",
    "title": "Delta-Science-Blog",
    "section": "Install homebrew",
    "text": "Install homebrew\nTo install homebrew on your computer: paste this command in your terminal window and hit enter. After hitting enter the script will explain what it will do and then pauses before it does it:\n{default} /bin/bash -c ‚Äú$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)‚Äù"
  },
  {
    "objectID": "drafts/draft_01.html#check-homebrew-installedversion-1",
    "href": "drafts/draft_01.html#check-homebrew-installedversion-1",
    "title": "Delta-Science-Blog",
    "section": "Check homebrew (installed/version)",
    "text": "Check homebrew (installed/version)\nTo verify and check whether you have homebrew already installed you can the following command. In case you have homebrew installed the output will tell you which version it is. If you don‚Äôt have it installed yet, the output will tell you something like command not found.\n{default} brew ‚Äìversion\nExample output in case your computer has homebrew installed (your version might differ):\n{default} Homebrew 3.6.6 Homebrew/homebrew-core (git revision 7ec3c2d24e8; last commit 2022-10-24) Homebrew/homebrew-cask (git revision c3048a8013; last commit 2022-10-24)"
  },
  {
    "objectID": "drafts/draft_01.html#update-homebrew-1",
    "href": "drafts/draft_01.html#update-homebrew-1",
    "title": "Delta-Science-Blog",
    "section": "Update homebrew",
    "text": "Update homebrew\nAfter having verified that your computer has homebrew installed, update it to make sure you have the latest version. Just enter the following command in your terminal window and hit enter [*].\n{default}"
  },
  {
    "objectID": "drafts/draft_01.html#install-pyenv-via-homebrew-1",
    "href": "drafts/draft_01.html#install-pyenv-via-homebrew-1",
    "title": "Delta-Science-Blog",
    "section": "2. Install pyenv (via homebrew)",
    "text": "2. Install pyenv (via homebrew)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Delta-Science-Blog",
    "section": "",
    "text": "A Shortcut To Deep SQL Coding\n\n\n\n\n\n\n\nsql\n\n\nr\n\n\nsnowflake\n\n\nproductivity\n\n\n\n\n\n\n\n\n\n\n\nMay 24, 2023\n\n\nGG Supp\n\n\n\n\n\n\n  \n\n\n\n\nUsing Jupyter Notebook in virtual environments in a free source-code editor (VSCodium/VS Code)\n\n\n\n\n\n\n\npython\n\n\nproductivity\n\n\nsetup\n\n\n\n\n\n\n\n\n\n\n\nNov 23, 2022\n\n\nGG Supp\n\n\n\n\n\n\n  \n\n\n\n\nSave time & nerves: start controlling different Python versions (pyenv) and managing virtual environments (virtualenvwrapper)\n\n\n\n\n\n\n\npython\n\n\nproductivity\n\n\nsetup\n\n\n\n\n\n\n\n\n\n\n\nNov 4, 2022\n\n\nGG Supp\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This blog reflects some of the off-springs related to my work at Delta-Science (digital research, data science & data engineering) to document selected challenges I had to resolve on the way. I am writing these pieces in the hope that this information may help others with similar challenges to find working solutions faster, making them more intelligible and reproducible.\nUnderstanding is a constant quest and I am grateful to the crowd wisdom of diverse communities that I can tap into (crediting and thanking original contributions that I could replicate myself on the way).\nArtwork¬†attribution:¬†Freepik"
  },
  {
    "objectID": "posts/post-three/index.html",
    "href": "posts/post-three/index.html",
    "title": "A Shortcut To Deep SQL Coding",
    "section": "",
    "text": "Summary\nSQL coding is an important part of data engineering, but mastering it can be a difficult and lengthy process. However, existing knowledge from other programming languages like Python or R can help bridge the gap to SQL. This post describes the exemplary usage of a handy translation tool that enables users to generate SQL code based on familiar commands in R (by using two packages from the mighty tidyverse).\n\n\nThis post is in appreciation of Hengji from DBC for all the great SQL mentoring he has provided.\n\n\n\nIntroduction\nSQL coding is essential for many data engineering applications or services, especially when working with modern data warehouses like Snowflake and Databricks, as well as for data modelling in dbt.\nClearly not everybody can be considered ‚Äúnative‚Äù in SQL and mastering it from scratch can be a daunting and time-consuming. Yet what if our existing knowledge could actually help us learn a new language?\nSince many data professionals have already cultivated programming skills in languages like Python, R, Octave, Julia, etc. I was always wandering how the knowledge of one coding language might support the acquisition of another one.\nOne might be tempted to think that the knowledge of one programming language might make it harder to learn a different one. The variations in syntax, function names, data types, and so on can quickly lead to confusion and make the learning process more challenging.\nHowever, what if we can use translations tools in order to make the switch to SQL easier and progressive? Using translation tools, we can start to learn in a step-by-step approach, making it easier not only to get started but also to go deeper into SQL.\nIn the current post I will showcase a powerful translation tool that generates SQL code based on R commands by using the R packages dplyr and dbplyr both from the popular tidyverse collection. The examples provided here below assume some background in R and data manipulation using dplyr (if you would like to get a head start, you could check out this helpful tutorial for dplyr which includes many illustrative code snippets).\n\n\nSetup\nThe setup we need is nothing more than having a current R version and an IDE installed on your computer. I am using RStudio together with the R version 4.3.0 (actually, the IDE is optional). In addition, in case you want to test your SQL code that we will generate together, you should have a place to run your SQL code (e.g.¬†by having a local Postgres database tool such as pgAdmin4 or a data warehouse in the cloud that allows SQL queries such as Snowflake). Thanks to DBC I have a trail version of Snowflake that I will use.\n\n\nDemo Data\nAs our toy data we will use a subset of weather API requests that were collected in the course of a data engineering project. The data contain atmospheric pressure and temperature records for three seperate locations, each about 25 km apart from another.\nLet‚Äôs load the demo data within R. To load the data in your R console we just need to read this linked CSV file (download and save it to the location of your choosing). Note that we also need to include several R packages using the command library(XXX) in our session first. In case you don‚Äôt have installed them in your system, you need to do this in advance - either within your IDE or using the console command install.packages(\"XXX\"):\n# Load Required Packages ####\nlibrary(readr)     # reading files\nlibrary(lubridate) # dealing with date/time\nlibrary(dbplyr)    # sql support \nlibrary(dplyr)     # sql support\nlibrary(RSQLite)   # sql support\n\n# Load Demo Data ####\nsrc_file = \"./data/d_demo.csv\"\nd_source <- read_csv(src_file, col_names = TRUE, show_col_types = FALSE)\n\n# Quick Data Overview\nglimpse(d_source)\n# Rows: 6,912\n# Columns: 8\n# $ ID_LOC          <chr> \"id2\", \"id2\", \"id2\", \"id2\", \"id2\", \"id2\", ‚Ä¶\n# $ TIME_ZONE       <chr> \"GMT\", \"GMT\", \"GMT\", \"GMT\", \"GMT\", \"GMT\", ‚Ä¶\n# $ TIMESTAMP       <dttm> 2023-04-23 03:39:13, 2023-04-23 03:39:13, ‚Ä¶\n# $ TIMESTAMP_UNIX  <dbl> 1.682221e+12, 1.682221e+12, 1.682221e+12, ‚Ä¶\n# $ TIME            <dttm> 2023-04-22 00:00:00, 2023-04-22 04:00:00, ‚Ä¶\n# $ PRESSURE_MSL    <dbl> 1015.4, 1014.2, 1015.6, 1015.6, 1015.4, ‚Ä¶\n# $ TEMPERATURE_2M  <dbl> 18.9, 17.7, 22.3, 20.5, 15.7, 17.6, 23.7, ‚Ä¶\n# $ TEMPERATURE_80M <dbl> 18.6, 19.8, 19.5, 20.0, 19.8, 20.4, 21.2, ‚Ä¶\nFrom the display of the sample information, there are around 6900 records listed across 8 columns. Additionally, there is a TIMESTAMP field that indicates when the API query was run, and an ID_LOC field displaying the location identifier for which weather details were obtained (three places in total: id1, id2, id3).\n\n\nFirst SQL Translation\nTo get a better undertstanding of the data, let‚Äôs ask some questions regarding the scope of the demo data: How often was the API request run for each location and how many days are present in the TIMESTAMP column?\nd_source %>% \n  count(TIMESTAMP, ID_LOC) %>% \n  mutate(prop = n/sum(n)) %>% \n  arrange(ID_LOC, TIMESTAMP) %>% \n  print(n=12) # restricting the output to the first 12 rows\n\n# A tibble: 36 √ó 4\n#   TIMESTAMP           ID_LOC     n   prop\n#    <dttm>              <chr>  <int>  <dbl>\n#  1 2023-04-23 05:57:35 id1      192 0.0278\n#  2 2023-04-23 11:57:35 id1      192 0.0278\n#  3 2023-04-23 17:57:35 id1      192 0.0278\n#  4 2023-04-23 23:57:36 id1      192 0.0278\n#  5 2023-04-24 05:57:36 id1      192 0.0278\n#  6 2023-04-24 11:57:36 id1      192 0.0278\n#  7 2023-04-24 17:57:36 id1      192 0.0278\n#  8 2023-04-24 23:57:36 id1      192 0.0278\n#  9 2023-04-25 05:57:37 id1      192 0.0278\n# 10 2023-04-25 11:57:37 id1      192 0.0278\n# 11 2023-04-25 17:57:37 id1      192 0.0278\n# 12 2023-04-25 23:57:37 id1      192 0.0278\n# # ‚Ñπ 24 more rows\nThat is, the demo data contain 3 days of API requests, 4 requests per day for each location, making in total 3 x 4 x 3 = 36 individual timestamps (API requests).\nHow can we get this exact timestamp-based summary translated to a proper SQL command? That‚Äôs quite easy: we just need to add two additional commands to the basic R code shown before, memdb_frame() at the beginning and show_query() at the end:\n memdb_frame(d_source) %>% \n  count(TIMESTAMP, ID_LOC) %>% \n  mutate(prop = n/sum(n)) %>% \n  arrange(ID_LOC, TIMESTAMP) %>% \n  show_query()\n \n# <SQL>\n# SELECT *, `n` / SUM(`n`) OVER () AS `prop`\n# FROM (\n#   SELECT `TIMESTAMP`, `ID_LOC`, COUNT(*) AS `n`\n#   FROM `dbplyr_003`\n#   GROUP BY `TIMESTAMP`, `ID_LOC`\n# )\n# ORDER BY `ID_LOC`, `TIMESTAMP`\nWe can utilize this SQL code in Snowflake, omitting the quotation marks. Remember to substitute the dataframe name with the actual table name, i.e.¬†D_SOURCE.\nSELECT *, n / SUM(n) OVER () AS prop\nFROM (\n  SELECT TIMESTAMP, ID_LOC, COUNT(*) AS n\n  FROM D_SOURCE\n  GROUP BY TIMESTAMP, ID_LOC\n)\nORDER BY ID_LOC, TIMESTAMP\n\n\n\nSnowflake: Worksheet with results\n\n\nNice, right? We made our first translation into SQL. If you know SQL already a bit, you will know about Common Table Expressions (CTEs). We can rephrase the code from the translation by using a CTE (please click the callout box below, if you are interested).\n\n\n\n\n\n\nGoing (a bit) pro: Using a CTE\n\n\n\n\n\nThe output from show_query() can be refined by restructuring the SQL statement to include a CTE (Common Table Expression) in the beginning instead of using a nested structure in the middle of the code. It seems to be a widely shared opionion that programming SQL in this manner makes it easier to interpret for humans.\nWITH tmp_cte AS (\nSELECT TIMESTAMP, ID_LOC, COUNT(*) AS n\n  FROM D_SOURCE\n  GROUP BY TIMESTAMP, ID_LOC\n)\nSELECT *, n / SUM(n) OVER () AS prop\nFROM tmp_cte\nORDER BY ID_LOC, TIMESTAMP  \nHowever, needless to say, both approaches work fine (producing identical results).\n\n\n\nSnowflake: Worksheet with results (using CTE)\n\n\n\n\n\nIn case you are interested why we need to apply memdb_frame() to our data frame containing our data: this function creates an actual table (instead of a data frame) in a temporary in-memory database (see the documentation for more details).\n\n\nSecond SQL Translation\nBased on our timestamp-based summary seen before it seems that there is considerable redundancy in the demo data. Let‚Äôs only keep for each day the data from a single API call collected for each location (n=3), so that we end up with 3 x 3 = 9 individual TIMESTAMPS. Currently, we have 4 API calls per day, but we only want to keep the latest one for a given day.\nHow should we do that? By following these steps:\n\nCreating a new column containing the day of a given timestamp (named TIMESTAMP_DAY)\nGroup the data based on two attributes: location and day of the timestamp (ID_LOC and TIMESTAMP_DAY)\nSelecting the latest/highest (maximum) timestamp from the grouped data\n\nThe following R code can be used to implement and confirm the results of these operations (1 API call per location and day):\nd_work1 <-\n  d_source %>%\n  mutate(TIMESTAMP_DAY = date(TIMESTAMP)) %>% \n  group_by(ID_LOC, TIMESTAMP_DAY) %>% \n  slice_max(TIMESTAMP, n=1) %>% \n  ungroup()\n\nd_work1 %>% \n  count(TIMESTAMP, ID_LOC) %>% \n  mutate(prop = n/sum(n)) %>% \n  arrange(ID_LOC, TIMESTAMP)\n\n# # A tibble: 9 √ó 4\n#   TIMESTAMP           ID_LOC     n  prop\n#   <dttm>              <chr>  <int> <dbl>\n# 1 2023-04-23 23:57:36 id1      192 0.111\n# 2 2023-04-24 23:57:36 id1      192 0.111\n# 3 2023-04-25 23:57:37 id1      192 0.111\n# 4 2023-04-23 21:39:14 id2      192 0.111\n# 5 2023-04-24 21:00:18 id2      192 0.111\n# 6 2023-04-25 21:00:19 id2      192 0.111\n# 7 2023-04-23 21:42:50 id3      192 0.111\n# 8 2023-04-24 21:42:51 id3      192 0.111\n# 9 2023-04-25 21:42:52 id3      192 0.111\nAgain, let‚Äôs translate this R code of the data transformation into SQL by including memdb_frame() at the beginning and show_query() at the end of the code:\nmemdb_frame(d_source) %>% \n  mutate(TIMESTAMP_DAY = date(TIMESTAMP)) %>% \n  group_by(ID_LOC, TIMESTAMP_DAY) %>% \n  slice_max(TIMESTAMP, n=1) %>% \n  ungroup() %>% \n  show_query()\n\n# <SQL>\n# SELECT\n#   `ID_LOC`,\n#   `TIME_ZONE`,\n#   `TIMESTAMP`,\n#   `TIMESTAMP_UNIX`,\n#   `TIME`,\n#   `PRESSURE_MSL`,\n#   `TEMPERATURE_2M`,\n#   `TEMPERATURE_80M`,\n#   `TIMESTAMP_DAY`\n# FROM (\n#   SELECT\n#     *,\n#     RANK() OVER (PARTITION BY `ID_LOC`, `TIMESTAMP_DAY` ORDER BY `TIMESTAMP` DESC) AS `q01`\n#   FROM (\n#     SELECT *, date(`TIMESTAMP`) AS `TIMESTAMP_DAY`\n#     FROM `dbplyr_004`\n#   )\n# )\n# WHERE (`q01` <= 1)\nWe can utilize this SQL code again in Snowflake, after omitting the quotation marks.\nSELECT\n  ID_LOC,\n  TIME_ZONE,\n  TIMESTAMP,\n  TIMESTAMP_UNIX,\n  TIME,\n  PRESSURE_MSL,\n  TEMPERATURE_2M,\n  TEMPERATURE_80M,\n  TIMESTAMP_DAY\nFROM (\n  SELECT\n    *,\n    RANK() OVER (PARTITION BY ID_LOC, TIMESTAMP_DAY ORDER BY TIMESTAMP DESC) AS q01\n  FROM (\n    SELECT *, date(TIMESTAMP) AS TIMESTAMP_DAY\n    FROM D_SOURCE\n  )\n)\nWHERE (q01 <= 1)\nAs you can see in the SQL code this time we find a so called window function in our translation. In general, a SQL window function applies aggregate and ranking operation over a particular data window (i.e.¬†a set of rows). I am refering to the code part starting with RANK() and ending with the ORDER BY() statement. You can read a nice and concise summary on this topic following the link above (or here).\n\n\n\n\n\n\nSQL rephrased: Again using a CTE\n\n\n\n\n\nWe can rephrase the SQL code from above by defining a CTE at the top and integrating the window function there:\nWITH tmp_cte AS (\nSELECT\n  ID_LOC,\n  TIME_ZONE,\n  TIMESTAMP,\n  TIMESTAMP_UNIX,\n  TIME,\n  PRESSURE_MSL,\n  TEMPERATURE_2M,\n  TEMPERATURE_80M,\n  TIMESTAMP_DAY,\n  RANK() OVER (PARTITION BY ID_LOC, TIMESTAMP_DAY ORDER BY TIMESTAMP DESC) AS q01\n  FROM (\n    SELECT *, date(TIMESTAMP) AS TIMESTAMP_DAY\n    FROM D_SOURCE\n  )\n)\nSELECT\n *\nFROM tmp_cte \nWHERE (q01 <= 1)\nLet‚Äôs run the rephrased code in Snowflake providing the same results as before.\n\n\n\nSnowflake: Worksheet with results\n\n\n\n\n\nI am hoping that these two examples have been interesting enough to get you started on your own exploration and the illustrated translation tool may be a useful resource for your learning journey.\nHappy coding & Cheers! üòÉ\n\n\n\n\n\n\nPS: How do I upload a local data file into Snowflake?\n\n\n\n\n\nIn case you would like to replicate some of the SQL code directly in Snowflake, you would need to upload your local data file and make it available as a table. Please find the demo data as parquet file in the link (download the file and save it on your local machine).\nNow, uploading this data file to Snowflake can be done in two simple steps:\n\nCreate the destination table: this table is empty at the moment of creation, but for creating the table you need to define the data schema, i.e.¬†column names and data types (see the details below).\nWithin the Snowflake UI go to the database section and select a specific table, namely the one that was just created created: click on the ‚ÄúLoad Data‚Äù button and select the previously dowloaded parquet-file containing the demo data.\n\n\nStep 1\nWhen creating the table in Snowflake we need to define the column definitions, i.e.¬†providing a name for each column and the data type specification of each column. The column definitions are separated by commas. For our concrete example the destination table (named D_SOURCE) with its 8 columns is created in Snowflake as follows:\nCREATE TABLE D_SOURCE(\nID_LOC VARCHAR,\nTIME_ZONE VARCHAR, \nTIMESTAMP TIMESTAMP_NTZ(9),\nTIMESTAMP_UNIX NUMBER(38,0),\nTIME TIMESTAMP_NTZ(9),\nPRESSURE_MSL FLOAT,\nTEMPERATURE_2M FLOAT,\nTEMPERATURE_80M FLOAT\n)\n\n\nStep 2\nWithin the Snowflake UI navigate to the database section and select the database and the schema that contains the previously created destination table (in our example: D_SOURCE). When you have selected this table, you will see blue action button on the top right corner named ‚ÄúLoad Data‚Äù (see the screenshot below)\nNext you are prompted to browse and select the local file that you want to upload. Find the previously downloaded file demo_file.parquet and click ‚ÄúNext‚Äù.\n\n\n\nSnowflake UI: Select parquet file\n\n\nFinally, select the right file format ‚ÄúParquet‚Äù and finish the upload process.\n\n\n\nSnowflake UI: Select file format\n\n\nYour efforts should be reworded by the following ‚Äúsuccess‚Äù feedback. That is, you are good to go using the data uploaded into the destination table. üôå\n\n\n\nSnowflake UI: Upload succeeded"
  }
]